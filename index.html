<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>App Educativo — Padrões no Caminho de Contas (6×N) V/A/E</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 16px; background:#0b0f14; color:#e8eef7; }
    h1,h2 { margin: 0 0 10px; }
    .row { display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
    .card { background:#111826; border:1px solid #223049; border-radius:12px; padding:14px; box-shadow: 0 6px 18px rgba(0,0,0,.25); }
    .card h2 { font-size: 16px; color:#cfe0ff; margin-bottom: 10px; }
    textarea, input, select {
      width: 100%; box-sizing: border-box; color:#e8eef7; background:#0b1220;
      border:1px solid #223049; border-radius:10px; padding:10px; outline:none;
    }
    textarea { min-height: 110px; resize: vertical; }
    button {
      background:#1d4ed8; color:white; border:0; border-radius:10px;
      padding:10px 12px; cursor:pointer; font-weight:800;
    }
    button.secondary { background:#243248; }
    button.danger { background:#b91c1c; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .hint { font-size: 12px; color:#a9b7d0; line-height: 1.35; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .hr { height:1px; background:#223049; margin: 10px 0; }
    .split { display:flex; gap:10px; flex-wrap:wrap; }
    .split > div { flex: 1 1 240px; }
    .actions { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; align-items:center; }
    .small { font-size: 12px; }

    .tag {
      display:inline-block; padding:2px 8px; border-radius:999px;
      background:#243248; color:#cfe0ff; border:1px solid #334766; font-size:12px;
    }
    .ok { background:#0f2f1b; border-color:#1c7c3a; }
    .no { background:#2f0f0f; border-color:#b91c1c; }

    /* Click input buttons */
    .pillBtn{
      border:1px solid #223049; background:#0b1220;
      padding:10px 12px; border-radius:12px;
      font-weight:900; min-width: 90px;
      display:flex; justify-content:center; align-items:center;
    }
    .pillBtn.V { background:#5b0b14; border-color:#a11b2f; }
    .pillBtn.A { background:#083a6b; border-color:#1c64b5; }
    .pillBtn.E { background:#2a2a2a; border-color:#5b5b5b; }

    /* Grid with headers */
    .gridContainer {
      display:grid;
      grid-template-columns: 52px 1fr;
      grid-template-rows: 34px 1fr;
      gap: 8px;
      align-items: start;
    }
    .cornerBox{
      width:52px; height:34px;
      border:1px solid #223049; border-radius:10px;
      background:#0b1220;
      display:flex; align-items:center; justify-content:center;
      color:#a9b7d0; font-size:12px;
    }
    .colHeaderWrap {
      overflow:auto;
      border:1px solid #223049; border-radius:10px;
      background:#0b1220;
      padding:6px;
    }
    .colHeaderRow {
      display:grid;
      grid-auto-flow: column;
      grid-auto-columns: 46px;
      gap:6px;
    }
    .colHead {
      width:46px; height:22px;
      border-radius:8px;
      border:1px solid #223049;
      display:flex; align-items:center; justify-content:center;
      font-size:11px; color:#a9b7d0;
      background:#0f172a;
    }
    .rowHeaderWrap{
      border:1px solid #223049; border-radius:10px;
      background:#0b1220;
      padding:6px;
    }
    .rowHeads{
      display:grid;
      grid-template-rows: repeat(6, 46px);
      gap:6px;
    }
    .rowHead{
      width:40px; height:46px;
      border-radius:10px;
      border:1px solid #223049;
      display:flex; align-items:center; justify-content:center;
      font-size:11px; color:#a9b7d0;
      background:#0f172a;
    }

    .gridWrap { overflow:auto; border-radius:12px; border:1px solid #223049; background:#0b1220; }
    .grid {
      display:grid; gap:6px; padding:10px; background:#0b1220;
      grid-auto-flow: column;
      grid-auto-columns: 46px;
      grid-template-rows: repeat(6, 46px);
      align-items: center;
    }
    .cell {
      width:46px; height:46px; border-radius:10px; border:1px solid #223049;
      display:flex; align-items:center; justify-content:center;
      font-weight:900; user-select:none;
      background:#0f172a;
    }
    .V { background:#5b0b14; border-color:#a11b2f; }
    .A { background:#083a6b; border-color:#1c64b5; }
    .E { background:#2a2a2a; border-color:#5b5b5b; }
    .empty { opacity:.35; }
    .cell small { font-size: 11px; opacity:.9; }

    /* Highlights */
    .hlAnchor { outline: 3px solid rgba(255,255,255,.85); }
    .hlCond   { outline: 3px solid rgba(250,204,21,.90); }
    .hlTarget { outline: 3px solid rgba(34,197,94,.90); }
    .hlNext   { box-shadow: 0 0 0 3px rgba(29,78,216,.9) inset; }

    /* Tables */
    table { width:100%; border-collapse: collapse; font-size: 13px; }
    th, td { border-bottom: 1px solid #223049; padding:8px; text-align:left; vertical-align: top; }
    th { color:#cfe0ff; font-weight:900; }
    tr.clickable:hover td { background: rgba(29,78,216,.12); cursor:pointer; }
  </style>
</head>
<body>
  <h1>App Educativo — Padrões no “Caminho de Contas” (6×N) — V/A/E</h1>
  <p class="hint">
    O “próximo resultado” sempre preenche a próxima célula na ordem: coluna 1 de cima para baixo (6 linhas), depois coluna 2, etc.
    Quando um padrão estiver pronto e o TARGET cair exatamente nessa próxima célula, o app gera um “sinal” com a % histórica do TARGET.
  </p>

  <div class="row">
    <div class="card" style="flex:1 1 520px;">
      <h2>1) Entrada por clique (análise automática)</h2>

      <div class="actions">
        <button class="pillBtn V" id="btnAddV">V</button>
        <button class="pillBtn A" id="btnAddA">A</button>
        <button class="pillBtn E" id="btnAddE">E</button>
        <button class="secondary" id="btnUndo">Desfazer</button>
        <button class="danger" id="btnClear">Limpar</button>
      </div>

      <div class="split" style="margin-top:10px;">
        <div>
          <div class="hint"><span class="tag">Contagem</span> <span id="countLbl" class="mono">0/130</span></div>
          <div class="hint" style="margin-top:6px;">
            <span class="tag">Próxima célula</span> <span id="nextCellLbl" class="mono">L1, C1</span>
          </div>
        </div>
        <div>
          <label class="small">Mínimo de ocorrências do padrão (para mostrar sinal)</label>
          <input id="minOccInput" type="number" min="1" step="1" value="3" />
          <div class="hint">“Mais de 2 vezes” ⇒ padrão: <b>3</b>.</div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="hint">Opcional: colar histórico (V/A/E) e aplicar:</div>
      <textarea id="historyInput" placeholder="Ex.: V A E V A ... ou VAEVA..."></textarea>
      <div class="actions">
        <button class="secondary" id="btnNormalizePaste">Normalizar e aplicar</button>
        <button class="secondary" id="btnLoadSample">Carregar exemplo</button>
      </div>
    </div>

    <div class="card" style="flex:1 1 640px;">
      <h2>2) Grade (visual) + sinais para o próximo Target</h2>

      <div class="gridContainer">
        <div class="cornerBox">L/C</div>
        <div class="colHeaderWrap"><div id="colHeaders" class="colHeaderRow"></div></div>
        <div class="rowHeaderWrap"><div class="rowHeads" id="rowHeaders"></div></div>
        <div class="gridWrap"><div id="grid" class="grid"></div></div>
      </div>

      <div class="hr"></div>

      <h2 style="margin-top:0;">Sinais para o próximo Target</h2>
      <div id="signalsBox" class="hint">Sem sinais no momento.</div>

      <div class="actions" style="margin-top:10px;">
        <button id="btnClearHighlight" class="secondary" disabled>Limpar destaque</button>
      </div>
    </div>
  </div>

  <div class="row" style="margin-top:16px;">
    <div class="card" style="flex:1 1 560px;">
      <h2>3) Padrões cadastrados</h2>
      <div class="hint">
        Padrões detectam em qualquer posição onde caibam. Âncora do usuário é <span class="mono">C0,L1</span>.
        <span class="mono">X</span>=âncora, <span class="mono">!X</span>=contrário (apenas V/A), <span class="mono">VA</span>=V ou A, <span class="mono">E</span>=empate.
      </div>

      <div class="hr"></div>
      <label class="small">Selecionar padrão</label>
      <select id="patternSelect"></select>
      <div class="actions">
        <button id="btnRemovePattern" class="danger">Remover selecionado</button>
      </div>

      <div class="hr"></div>
      <h2 style="margin-top:0;">Adicionar novo padrão (opcional)</h2>
      <div class="split">
        <div>
          <label class="small">Nome</label>
          <input id="newPatternName" placeholder="Ex.: Meu padrão X" />
        </div>
        <div>
          <label class="small">Âncora permitida</label>
          <select id="newPatternAnchorAllowed">
            <option value="VA">V ou A</option>
            <option value="E">E</option>
            <option value="VAE">V/A/E</option>
          </select>
        </div>
      </div>
      <div class="split" style="margin-top:10px;">
        <div>
          <label class="small">Condições (uma por linha)</label>
          <textarea id="newPatternConds" class="mono" placeholder="C0,L2 = X&#10;C1,L1 = !X"></textarea>
        </div>
        <div>
          <label class="small">TARGET</label>
          <input id="newPatternTarget" class="mono" placeholder="C2,L1 = X" />
          <div class="actions">
            <button id="btnAddPattern">Adicionar padrão</button>
          </div>
        </div>
      </div>
    </div>

    <div class="card" style="flex:1 1 620px;">
      <h2>4) Relatório técnico (resumo)</h2>
      <div id="reportSummary" class="hint">Adicione resultados para atualizar automaticamente.</div>

      <div class="actions" style="margin-top:10px;">
        <button id="btnExportJSON" class="secondary" disabled>Exportar JSON</button>
        <button id="btnExportCSV" class="secondary" disabled>Exportar CSV</button>
      </div>

      <div class="hr"></div>

      <h2 style="margin-top:0;">Ocorrências (clique para destacar)</h2>
      <div style="overflow:auto; border:1px solid #223049; border-radius:12px;">
        <table id="occTable">
          <thead>
            <tr>
              <th>Padrão</th>
              <th>Âncora</th>
              <th>X</th>
              <th>Previsto</th>
              <th>Real</th>
              <th>Resultado</th>
              <th>% V/A/E no Target (histórico)</th>
            </tr>
          </thead>
          <tbody>
            <tr><td colspan="7" class="muted">Sem dados.</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

<script>
/* =========================
   Config
   ========================= */
const MAX_ITEMS = 130;
const ROWS = 6;
const USER_ANCHOR_L = 1; // âncora em C0,L1

/* =========================
   Estado
   ========================= */
let state = {
  seq: [],
  grid: null,
  patterns: [],
  lastAnalysis: null,
  highlighted: null,
};

/* =========================
   Elementos
   ========================= */
const el = {
  btnAddV: document.getElementById("btnAddV"),
  btnAddA: document.getElementById("btnAddA"),
  btnAddE: document.getElementById("btnAddE"),
  btnUndo: document.getElementById("btnUndo"),
  btnClear: document.getElementById("btnClear"),
  countLbl: document.getElementById("countLbl"),
  nextCellLbl: document.getElementById("nextCellLbl"),

  historyInput: document.getElementById("historyInput"),
  btnNormalizePaste: document.getElementById("btnNormalizePaste"),
  btnLoadSample: document.getElementById("btnLoadSample"),

  minOccInput: document.getElementById("minOccInput"),

  colHeaders: document.getElementById("colHeaders"),
  rowHeaders: document.getElementById("rowHeaders"),
  grid: document.getElementById("grid"),

  signalsBox: document.getElementById("signalsBox"),
  btnClearHighlight: document.getElementById("btnClearHighlight"),

  patternSelect: document.getElementById("patternSelect"),
  btnRemovePattern: document.getElementById("btnRemovePattern"),

  newPatternName: document.getElementById("newPatternName"),
  newPatternAnchorAllowed: document.getElementById("newPatternAnchorAllowed"),
  newPatternConds: document.getElementById("newPatternConds"),
  newPatternTarget: document.getElementById("newPatternTarget"),
  btnAddPattern: document.getElementById("btnAddPattern"),

  reportSummary: document.getElementById("reportSummary"),
  occTableBody: document.querySelector("#occTable tbody"),

  btnExportJSON: document.getElementById("btnExportJSON"),
  btnExportCSV: document.getElementById("btnExportCSV"),
};

/* =========================
   Utilitários
   ========================= */
function parseHistory(raw) {
  const chars = (raw || "").toUpperCase().match(/[VAE]/g) || [];
  return chars.slice(0, MAX_ITEMS);
}
function sequenceToGrid(seq) {
  const cols = Math.ceil(seq.length / ROWS) || 1;
  const grid = Array.from({ length: ROWS }, () => Array(cols).fill(null));
  let idx = 0;
  for (let c = 0; c < cols; c++) {
    for (let r = 0; r < ROWS; r++) {
      if (idx >= seq.length) break;
      grid[r][c] = seq[idx++];
    }
  }
  return grid;
}
function inBounds(grid, r, c) {
  return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;
}
function cellValue(grid, r, c) {
  if (!grid) return null;
  if (!inBounds(grid, r, c)) return null;
  const v = grid[r][c];
  return (v === "V" || v === "A" || v === "E") ? v : null;
}
function oppositeVA(color) {
  if (color === "V") return "A";
  if (color === "A") return "V";
  return null;
}
function userToInternalDr(drUser) { return drUser - USER_ANCHOR_L; }
function formatPct(x) {
  if (x === null || Number.isNaN(x)) return "N/A";
  return `${(x*100).toFixed(1)}%`;
}
function formatDistPct(d) {
  if (!d || d.V === null) return "N/A";
  return `V ${formatPct(d.V)} | A ${formatPct(d.A)} | E ${formatPct(d.E)}`;
}
function nextCellFromSeqLen(n) {
  // próximo índice é n
  const r = n % ROWS;
  const c = Math.floor(n / ROWS);
  return { r, c };
}
function coordToIndex(r,c) { return c*ROWS + r; }

/* =========================
   Render headers + grid
   ========================= */
function renderHeaders(cols) {
  el.rowHeaders.innerHTML = "";
  for (let r = 0; r < ROWS; r++) {
    const d = document.createElement("div");
    d.className = "rowHead";
    d.textContent = `L${r+1}`;
    el.rowHeaders.appendChild(d);
  }
  el.colHeaders.innerHTML = "";
  for (let c = 0; c < cols; c++) {
    const d = document.createElement("div");
    d.className = "colHead";
    d.textContent = `C${c+1}`;
    el.colHeaders.appendChild(d);
  }
}

function renderGrid(grid) {
  el.grid.innerHTML = "";
  if (!grid) return;

  const cols = grid[0].length;
  renderHeaders(cols);

  const next = nextCellFromSeqLen(state.seq.length);
  el.nextCellLbl.textContent = `L${next.r+1}, C${next.c+1}`;

  for (let c = 0; c < cols; c++) {
    for (let r = 0; r < ROWS; r++) {
      const v = grid[r][c];
      const div = document.createElement("div");
      div.className = `cell ${v === "V" ? "V" : v === "A" ? "A" : v === "E" ? "E" : "empty"}`;
      div.dataset.r = String(r);
      div.dataset.c = String(c);
      div.title = `L${r+1}, C${c+1}`;
      div.innerHTML = v ? v : "<small>•</small>";
      el.grid.appendChild(div);
    }
  }

  // marca a próxima célula (se ela já existir no grid)
  const nextEl = cellEl(next.r, next.c);
  if (nextEl) nextEl.classList.add("hlNext");

  // reaplica highlight se existir
  if (state.highlighted) applyHighlight(state.highlighted);
}

function updateCountLabel() {
  el.countLbl.textContent = `${state.seq.length}/${MAX_ITEMS}`;
}

/* =========================
   Highlight
   ========================= */
function cellEl(r,c) {
  return el.grid.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
}
function clearHighlight() {
  document.querySelectorAll(".hlAnchor,.hlCond,.hlTarget").forEach(n => {
    n.classList.remove("hlAnchor","hlCond","hlTarget");
  });
  state.highlighted = null;
  el.btnClearHighlight.disabled = true;
}
function applyHighlight(h) {
  clearHighlight();
  state.highlighted = h;

  const a = cellEl(h.anchor.r, h.anchor.c);
  if (a) a.classList.add("hlAnchor");

  for (const cc of h.condCells) {
    const ce = cellEl(cc.r, cc.c);
    if (ce) ce.classList.add("hlCond");
  }
  const t = cellEl(h.target.r, h.target.c);
  if (t) t.classList.add("hlTarget");

  el.btnClearHighlight.disabled = false;
}

/* =========================
   Engine de padrões
   =========================
   kinds: X | !X | V | A | E | VA
*/
function expectedSetFromKind(kind, anchorX) {
  if (kind === "X") return [anchorX];
  if (kind === "!X") {
    const o = oppositeVA(anchorX);
    return o ? [o] : null;
  }
  if (kind === "VA") return ["V","A"];
  if (kind === "V" || kind === "A" || kind === "E") return [kind];
  return null;
}
function anchorAllowedSet(code) {
  if (code === "VA") return ["V","A"];
  if (code === "E") return ["E"];
  if (code === "VAE") return ["V","A","E"];
  return ["V","A"];
}

function evaluateAtAnchor(grid, pattern, anchorR, anchorC) {
  const X = cellValue(grid, anchorR, anchorC);
  if (!X) return null;

  const allowed = anchorAllowedSet(pattern.anchorAllowed || "VA");
  if (!allowed.includes(X)) return null;

  const condCells = [];
  for (const cond of pattern.conditions) {
    const rr = anchorR + cond.dr;
    const cc = anchorC + cond.dc;
    const expectedSet = expectedSetFromKind(cond.kind, X);
    if (!expectedSet) return null;

    const actual = cellValue(grid, rr, cc);
    if (!actual) return null;
    if (!expectedSet.includes(actual)) return null;

    condCells.push({ r: rr, c: cc });
  }

  const tr = anchorR + pattern.target.dr;
  const tc = anchorC + pattern.target.dc;
  const predictedSet = expectedSetFromKind(pattern.target.kind, X);
  if (!predictedSet) return null;

  const actual = cellValue(grid, tr, tc);
  const measured = !!actual;
  const hit = measured ? predictedSet.includes(actual) : null;

  return {
    patternId: pattern.id,
    patternName: pattern.name,
    anchor: { r: anchorR, c: anchorC },
    X,
    predictedSet,
    predictedLabel: predictedSet.length === 1 ? predictedSet[0] : predictedSet.join("|"),
    actual,
    hit,
    condCells,
    targetCell: { r: tr, c: tc }
  };
}

function scanPattern(grid, pattern) {
  const rows = grid.length;
  const cols = grid[0].length;

  const occurrences = [];
  let triggers = 0;
  let measured = 0;
  let hits = 0;

  // distribuição real no target quando dispara (apenas medidos)
  const dist = { V:0, A:0, E:0 };

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const res = evaluateAtAnchor(grid, pattern, r, c);
      if (!res) continue;

      triggers++;
      if (res.actual) dist[res.actual]++;

      if (res.hit === true) { measured++; hits++; }
      else if (res.hit === false) { measured++; }

      occurrences.push(res);
    }
  }

  const accuracy = measured > 0 ? hits / measured : null;
  const distTotal = dist.V + dist.A + dist.E;
  const distPct = distTotal > 0 ? {
    V: dist.V / distTotal,
    A: dist.A / distTotal,
    E: dist.E / distTotal
  } : { V:null, A:null, E:null };

  return { patternId: pattern.id, patternName: pattern.name, triggers, measured, hits, accuracy, distPct, occurrences };
}

/* =========================
   Sinais para o próximo Target
   =========================
   Um sinal existe quando:
   - condições do padrão batem
   - targetCell == próxima célula (próximo índice)
   - (opcional) padrão tem >= minOcc ocorrências no histórico (gatilhos)
   - então mostramos P(target = cor necessária) = distPct[cor] (estimado no histórico atual)
*/
function buildSignals(analysis, minOcc) {
  if (!analysis) return [];

  const next = nextCellFromSeqLen(state.seq.length);
  const nextIndex = state.seq.length; // próximo resultado preencherá este índice

  // mapa patternId -> distPct e triggers
  const byId = new Map();
  for (const r of analysis.results) byId.set(r.patternId, r);

  const signals = [];

  for (const p of state.patterns) {
    const pr = byId.get(p.id);
    if (!pr) continue;
    if (pr.triggers < minOcc) continue;

    // varrer anchors e achar as que target == next
    const rows = state.grid.length;
    const cols = state.grid[0].length;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const ev = evaluateAtAnchor(state.grid, p, r, c);
        if (!ev) continue;

        // target tem que ser exatamente a próxima célula
        if (ev.targetCell.r !== next.r || ev.targetCell.c !== next.c) continue;

        // target ainda não existe (por definição do next) — mas garantimos:
        const idxTarget = coordToIndex(ev.targetCell.r, ev.targetCell.c);
        if (idxTarget !== nextIndex) continue;

        // probabilidade da(s) cor(es) necessárias:
        // se predictedSet = [V], prob = distPct.V
        // se predictedSet = [V,A], prob = distPct.V + distPct.A
        const d = pr.distPct;
        let prob = null;
        if (d.V !== null) {
          prob = ev.predictedSet.reduce((acc, color) => acc + (d[color] ?? 0), 0);
        }

        signals.push({
          patternName: p.name,
          anchor: ev.anchor,
          X: ev.X,
          predictedLabel: ev.predictedLabel,
          prob,
          distPct: d,
          highlight: { anchor: ev.anchor, condCells: ev.condCells, target: ev.targetCell }
        });
      }
    }
  }

  // ordenar por maior prob (se houver)
  signals.sort((a,b) => {
    if (a.prob === null && b.prob === null) return 0;
    if (a.prob === null) return 1;
    if (b.prob === null) return -1;
    return b.prob - a.prob;
  });

  return signals;
}

function renderSignals(signals) {
  if (!signals.length) {
    el.signalsBox.innerHTML = "Sem sinais no momento.";
    return;
  }

  const items = signals.slice(0, 12).map((s, idx) => {
    const anchorTxt = `Âncora L${s.anchor.r+1}, C${s.anchor.c+1}`;
    const probTxt = (s.prob === null) ? "Probabilidade: N/A (sem histórico medido suficiente)" : `Probabilidade de completar TARGET: <b>${formatPct(s.prob)}</b>`;
    const distTxt = formatDistPct(s.distPct);

    // payload para highlight
    const payload = encodeURIComponent(JSON.stringify(s.highlight));

    return `
      <div style="padding:10px; border:1px solid #223049; border-radius:12px; margin:8px 0; background:#0b1220;">
        <div><span class="tag">SINAL</span> <b>${s.patternName}</b></div>
        <div class="hint mono">${anchorTxt} | X=${s.X} | Target precisa: ${s.predictedLabel}</div>
        <div class="hint">${probTxt}</div>
        <div class="hint mono">Distribuição histórica no Target (quando disparou): ${distTxt}</div>
        <div class="actions">
          <button class="secondary" data-h="${payload}">Destacar na grade</button>
        </div>
      </div>
    `;
  }).join("");

  el.signalsBox.innerHTML = items;

  // bind buttons
  el.signalsBox.querySelectorAll("button[data-h]").forEach(btn => {
    btn.addEventListener("click", () => {
      const raw = btn.getAttribute("data-h");
      const h = JSON.parse(decodeURIComponent(raw));
      applyHighlight(h);
    });
  });
}

/* =========================
   Relatório (resumo + tabela)
   ========================= */
function setReport(msg) {
  el.reportSummary.textContent = msg;
  el.btnExportJSON.disabled = !state.lastAnalysis;
  el.btnExportCSV.disabled = !state.lastAnalysis;
}

function renderReport(analysis) {
  if (!analysis) {
    el.occTableBody.innerHTML = `<tr><td colspan="7" class="muted">Sem dados.</td></tr>`;
    return;
  }

  // base rate do histórico atual
  const baseCounts = state.seq.reduce((acc, v) => { acc[v] = (acc[v]||0)+1; return acc; }, {V:0,A:0,E:0});
  const baseTotal = baseCounts.V + baseCounts.A + baseCounts.E;
  const basePct = baseTotal ? { V: baseCounts.V/baseTotal, A: baseCounts.A/baseTotal, E: baseCounts.E/baseTotal } : {V:null,A:null,E:null};

  const minOcc = Math.max(1, Number(el.minOccInput.value || 3));
  const shown = analysis.results.filter(r => r.triggers >= minOcc);

  el.reportSummary.innerHTML = `
    <div class="hint">
      <div><span class="tag">Padrões com >= ${minOcc} ocorrências</span> ${shown.length}/${analysis.results.length}</div>
      <div><span class="tag">Base no histórico</span> V ${formatPct(basePct.V)} | A ${formatPct(basePct.A)} | E ${formatPct(basePct.E)}</div>
      <div class="hr"></div>
      ${shown.slice(0,8).map(r => `
        <div class="hint">
          <b>${r.patternName}</b><br/>
          gatilhos=${r.triggers}, medidos=${r.measured}, hits=${r.hits},
          acerto=${r.accuracy===null ? "N/A" : formatPct(r.accuracy)},
          target(V/A/E)=${formatDistPct(r.distPct)}
        </div>
      `).join("")}
      ${shown.length > 8 ? `<div class="muted">(+${shown.length-8} padrões no total)</div>` : ``}
    </div>
  `;

  // tabela de ocorrências (somente dos padrões exibidos)
  const flat = shown.flatMap(r => r.occurrences.map(o => ({
    ...o,
    _pattern: r.patternName,
    _distPct: r.distPct
  })));

  if (!flat.length) {
    el.occTableBody.innerHTML = `<tr><td colspan="7" class="muted">Sem ocorrências para exibir.</td></tr>`;
    return;
  }

  el.occTableBody.innerHTML = flat.slice(0, 200).map(o => {
    const anchor = `L${o.anchor.r+1}, C${o.anchor.c+1}`;
    const resTag = o.hit === null
      ? `<span class="tag">Sem alvo</span>`
      : o.hit ? `<span class="tag ok">HIT</span>` : `<span class="tag no">MISS</span>`;
    const real = o.actual ?? "—";
    const distTxt = formatDistPct(o._distPct);

    const payload = encodeURIComponent(JSON.stringify({
      anchor: o.anchor,
      condCells: o.condCells,
      target: o.targetCell
    }));

    return `
      <tr class="clickable" data-h="${payload}">
        <td>${o._pattern}</td>
        <td class="mono">${anchor}</td>
        <td class="mono">${o.X}</td>
        <td class="mono">${o.predictedLabel}</td>
        <td class="mono">${real}</td>
        <td>${resTag}</td>
        <td class="mono">${distTxt}</td>
      </tr>
    `;
  }).join("");

  document.querySelectorAll("#occTable tbody tr.clickable").forEach(tr => {
    tr.addEventListener("click", () => {
      const raw = tr.getAttribute("data-h");
      if (!raw) return;
      const h = JSON.parse(decodeURIComponent(raw));
      applyHighlight(h);
    });
  });
}

/* =========================
   Análise automática (core)
   ========================= */
function analyzeAuto() {
  if (!state.grid) return;

  const results = state.patterns.map(p => scanPattern(state.grid, p));
  state.lastAnalysis = {
    createdAt: new Date().toISOString(),
    seqLength: state.seq.length,
    cols: state.grid[0].length,
    results
  };

  const minOcc = Math.max(1, Number(el.minOccInput.value || 3));

  // construir sinais para o próximo Target
  const signals = buildSignals(state.lastAnalysis, minOcc);
  renderSignals(signals);

  // se existir sinal, destacar o primeiro automaticamente (opcional)
  // aqui: destaca o melhor por probabilidade se houver
  if (signals.length) {
    applyHighlight(signals[0].highlight);
  }

  renderReport(state.lastAnalysis);

  el.btnExportJSON.disabled = false;
  el.btnExportCSV.disabled = false;
}

/* =========================
   Entrada e reconstrução
   ========================= */
function rebuildFromSeq() {
  state.grid = sequenceToGrid(state.seq);
  renderGrid(state.grid);
  updateCountLabel();
  analyzeAuto();
}

function addResult(v) {
  if (state.seq.length >= MAX_ITEMS) return;
  state.seq.push(v);
  rebuildFromSeq();
}
function undo() {
  if (!state.seq.length) return;
  state.seq.pop();
  rebuildFromSeq();
}
function clearAll() {
  state.seq = [];
  state.grid = sequenceToGrid(state.seq);
  renderGrid(state.grid);
  updateCountLabel();
  clearHighlight();
  el.signalsBox.textContent = "Sem sinais no momento.";
  el.reportSummary.textContent = "Adicione resultados para atualizar automaticamente.";
  el.occTableBody.innerHTML = `<tr><td colspan="7" class="muted">Sem dados.</td></tr>`;
  state.lastAnalysis = null;
  el.btnExportJSON.disabled = true;
  el.btnExportCSV.disabled = true;
}

/* =========================
   Padrões (os seus)
   ========================= */
function mkCond(dc, drUser, kind){ return { dc, dr: userToInternalDr(drUser), kind }; }
function mkTarget(dc, drUser, kind){ return { dc, dr: userToInternalDr(drUser), kind }; }

function defaultPatterns() {
  const patterns = [];

  patterns.push({
    id: crypto.randomUUID(),
    name: "Padrão 2x1 (TARGET C2,L2 = X)",
    anchorAllowed: "VA",
    conditions: [ mkCond(0,2,"X"), mkCond(1,1,"!X"), mkCond(2,1,"X") ],
    target: mkTarget(2,2,"X")
  });

  patterns.push({
    id: crypto.randomUUID(),
    name: "Padrão 2x2 (TARGET C2,L1 = X)",
    anchorAllowed: "VA",
    conditions: [ mkCond(0,2,"X"), mkCond(1,1,"!X"), mkCond(1,2,"!X") ],
    target: mkTarget(2,1,"X")
  });

  patterns.push({
    id: crypto.randomUUID(),
    name: "Padrão Escadinha (TARGET C2,L1 = X)",
    anchorAllowed: "VA",
    conditions: [ mkCond(0,2,"X"), mkCond(0,3,"X"), mkCond(1,1,"!X"), mkCond(1,2,"!X") ],
    target: mkTarget(2,1,"X")
  });

  patterns.push({
    id: crypto.randomUUID(),
    name: "Padrão Escadinha invertido (TARGET C2,L3 = X)",
    anchorAllowed: "VA",
    conditions: [ mkCond(1,1,"!X"), mkCond(1,2,"!X"), mkCond(2,1,"X"), mkCond(2,2,"X") ],
    target: mkTarget(2,3,"X")
  });

  patterns.push({
    id: crypto.randomUUID(),
    name: "Padrão de alternância (TARGET C2,L1 = X)",
    anchorAllowed: "VA",
    conditions: [ mkCond(0,2,"X"), mkCond(0,3,"X"), mkCond(0,4,"X"), mkCond(1,1,"!X") ],
    target: mkTarget(2,1,"X")
  });

  patterns.push({
    id: crypto.randomUUID(),
    name: "Padrão alternância 2 (TARGET C5,L1 = !X)",
    anchorAllowed: "VA",
    conditions: [ mkCond(0,2,"X"), mkCond(1,1,"!X"), mkCond(2,1,"X"), mkCond(2,2,"X"), mkCond(3,1,"!X"), mkCond(4,1,"X") ],
    target: mkTarget(5,1,"!X")
  });

  patterns.push({
    id: crypto.randomUUID(),
    name: "Quebra da segunda linha após surf (TARGET C2,L1 = X)",
    anchorAllowed: "VA",
    conditions: [ mkCond(0,2,"X"), mkCond(0,3,"X"), mkCond(0,4,"X"), mkCond(1,1,"!X"), mkCond(1,2,"!X") ],
    target: mkTarget(2,1,"X")
  });

  patterns.push({
    id: crypto.randomUUID(),
    name: "Empate consecutivo (TARGET C0,L2 = E)",
    anchorAllowed: "E",
    conditions: [],
    target: mkTarget(0,2,"E")
  });

  patterns.push({
    id: crypto.randomUUID(),
    name: "Empate horizontal (TARGET C1,L1 = E)",
    anchorAllowed: "E",
    conditions: [],
    target: mkTarget(1,1,"E")
  });

  patterns.push({
    id: crypto.randomUUID(),
    name: "Empate alternado (C0,L2=VA; TARGET C0,L3=E)",
    anchorAllowed: "E",
    conditions: [ mkCond(0,2,"VA") ],
    target: mkTarget(0,3,"E")
  });

  patterns.push({
    id: crypto.randomUUID(),
    name: "Alternado na horizontal (C1,L1=VA; TARGET C2,L1=E)",
    anchorAllowed: "E",
    conditions: [ mkCond(1,1,"VA") ],
    target: mkTarget(2,1,"E")
  });

  return patterns;
}

/* =========================
   Add/remove patterns
   ========================= */
function renderPatternSelect() {
  el.patternSelect.innerHTML = "";
  state.patterns.forEach((p, idx) => {
    const opt = document.createElement("option");
    opt.value = p.id;
    opt.textContent = `${idx+1}. ${p.name}`;
    el.patternSelect.appendChild(opt);
  });
}

function removeSelectedPattern() {
  const id = el.patternSelect.value;
  if (!id) return;
  const idx = state.patterns.findIndex(p => p.id === id);
  if (idx < 0) return;
  state.patterns.splice(idx, 1);
  renderPatternSelect();
  rebuildFromSeq();
}

/* Parser para novo padrão */
function parseOffsetLine(line) {
  const cleaned = (line || "").replace(/\s+/g, "");
  const m = cleaned.match(/^C(-?\d+)(?:,)?L(-?\d+)=(\!?X|V|A|E|VA)$/i);
  if (!m) return null;
  const dc = Number(m[1]);
  const drUser = Number(m[2]);
  const rhs = m[3].toUpperCase();
  const kind = (rhs === "X") ? "X" : (rhs === "!X") ? "!X" : rhs;
  return { dc, drUser, kind };
}
function parseConditionsBlock(block) {
  const lines = (block || "").split(/\r?\n/).map(x => x.trim()).filter(Boolean);
  const parsed = [];
  for (const line of lines) {
    const o = parseOffsetLine(line);
    if (!o) return { ok:false, error:`Linha inválida: "${line}"` };
    parsed.push({ dc: o.dc, dr: userToInternalDr(o.drUser), kind: o.kind });
  }
  return { ok:true, conditions: parsed };
}
function addPatternFromUI() {
  const name = (el.newPatternName.value || "").trim();
  if (!name) { alert("Informe um nome."); return; }
  const anchorAllowed = el.newPatternAnchorAllowed.value || "VA";
  const condParse = parseConditionsBlock(el.newPatternConds.value);
  if (!condParse.ok) { alert(condParse.error); return; }
  const t = parseOffsetLine(el.newPatternTarget.value);
  if (!t) { alert('TARGET inválido. Ex.: "C2,L1 = X"'); return; }
  const target = { dc: t.dc, dr: userToInternalDr(t.drUser), kind: t.kind };

  state.patterns.push({ id: crypto.randomUUID(), name, anchorAllowed, conditions: condParse.conditions, target });
  renderPatternSelect();
  el.newPatternName.value = "";
  el.newPatternConds.value = "";
  el.newPatternTarget.value = "";
  rebuildFromSeq();
}

/* =========================
   Export
   ========================= */
function downloadText(filename, text) {
  const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
function exportJSON() {
  if (!state.lastAnalysis) return;
  const payload = {
    meta: { app: "educativo-grade-6xN", createdAt: state.lastAnalysis.createdAt },
    input: { seq: state.seq, rows: ROWS },
    patterns: state.patterns,
    analysis: state.lastAnalysis
  };
  downloadText("relatorio_padroes.json", JSON.stringify(payload, null, 2));
}
function exportCSV() {
  if (!state.lastAnalysis) return;
  const header = ["pattern","anchor_row","anchor_col","X","predicted","actual","hit","target_V_pct","target_A_pct","target_E_pct"].join(",");
  const rows = [];
  const minOcc = Math.max(1, Number(el.minOccInput.value || 3));
  const shown = state.lastAnalysis.results.filter(r => r.triggers >= minOcc);

  shown.forEach(r => {
    r.occurrences.forEach(o => {
      rows.push([
        `"${r.patternName.replaceAll('"','""')}"`,
        o.anchor.r+1,
        o.anchor.c+1,
        o.X,
        o.predictedLabel,
        o.actual ?? "",
        (o.hit === null ? "" : (o.hit ? "1" : "0")),
        (r.distPct.V === null ? "" : r.distPct.V.toFixed(6)),
        (r.distPct.A === null ? "" : r.distPct.A.toFixed(6)),
        (r.distPct.E === null ? "" : r.distPct.E.toFixed(6)),
      ].join(","));
    });
  });

  downloadText("ocorrencias_padroes.csv", [header, ...rows].join("\n"));
}

/* =========================
   Eventos
   ========================= */
el.btnAddV.addEventListener("click", () => addResult("V"));
el.btnAddA.addEventListener("click", () => addResult("A"));
el.btnAddE.addEventListener("click", () => addResult("E"));
el.btnUndo.addEventListener("click", () => undo());
el.btnClear.addEventListener("click", () => clearAll());

el.btnNormalizePaste.addEventListener("click", () => {
  state.seq = parseHistory(el.historyInput.value);
  rebuildFromSeq();
});
el.btnLoadSample.addEventListener("click", () => {
  const sample = "V A E V A A V E V V A V A V V E V A A V E A V V A A V E V A V V A A V V A V A E V V A V A A V E V V A V A E A V V E A V A V E A V V";
  el.historyInput.value = sample;
  state.seq = parseHistory(sample);
  rebuildFromSeq();
});

el.minOccInput.addEventListener("input", () => analyzeAuto());

el.btnClearHighlight.addEventListener("click", () => clearHighlight());

el.btnRemovePattern.addEventListener("click", () => removeSelectedPattern());
el.btnAddPattern.addEventListener("click", () => addPatternFromUI());

el.btnExportJSON.addEventListener("click", () => exportJSON());
el.btnExportCSV.addEventListener("click", () => exportCSV());

/* =========================
   Init
   ========================= */
state.patterns = defaultPatterns();
renderPatternSelect();
state.grid = sequenceToGrid(state.seq);
renderGrid(state.grid);
updateCountLabel();
setReport("Adicione resultados para atualizar automaticamente.");
el.btnExportJSON.disabled = true;
el.btnExportCSV.disabled = true;
</script>
</body>
</html>
